# Volatile
volatile是Java提供的一种轻量级的同步机制。Java 语言包含两种内在的同步机制：同步块（或方法）和 volatile 变量，相比于synchronized（synchronized通常称为重量级锁），volatile更轻量级，因为它不会引起线程上下文的切换和调度。但是volatile 变量的同步性较差（有时它更简单并且开销更低），而且其使用也更容易出错。

## volatile变量特性
- 保证可见性，不保证原子性
    - 当写一个volatile变量时，JMM会把该线程本地内存中的变量强制刷新到主内存中去；
    - 这个写会操作会导致其他线程中的缓存无效。

- 禁止进行指令重排序
    - 重排序操作不会对存在数据依赖关系的操作进行重排序
    - 重排序是为了优化性能，但是不管怎么重排序，单线程下程序的执行结果不能被改变

    *重排序在单线程下一定能保证结果的正确性，但是在多线程环境下，可能发生重排序，影响结果*

    使用volatile关键字修饰共享变量便可以禁止这种重排序。若用volatile修饰共享变量，在编译时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序,volatile禁止指令重排序也有一些规则：

    - 当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；

    - 在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。

    *即执行到volatile变量时，其前面的所有语句都执行完，后面所有语句都未执行。且前面语句的结果对volatile变量及其后面语句可见。*

## volatile实现原理
- 可见性

    处理器为了提高处理速度，不直接和内存进行通讯，而是将系统内存的数据独到内部缓存后再进行操作，但操作完后不知什么时候会写到内存。

    如果**对声明了volatile变量进行写操作时，JVM会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写会到系统内存。**这一步确保了如果有其他线程对声明了volatile变量进行修改，则立即更新主内存中数据。

    **但这时候其他处理器的缓存还是旧的，所以在多处理器环境下，为了保证各个处理器缓存一致，每个处理会通过嗅探在总线上传播的数据来检查自己的缓存是否过期，**当处理器发现自己缓存行对应的内存地址被修改了，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作时，**会强制重新从系统内存把数据读到处理器缓存里。**这一步确保了其他线程获得的声明了volatile变量都是从主内存中获取最新的。

- 有序性

    Lock前缀指令实际上相当于一个内存屏障（也称内存栅栏），它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。

## 使用场景

synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意**volatile关键字是无法替代synchronized关键字的**，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：

- 对变量的写操作不依赖于当前值
    
- 该变量没有包含在具有其他变量的不变式中

*单例模式的双重锁要加volatile*
