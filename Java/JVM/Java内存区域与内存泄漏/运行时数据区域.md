# 运行时数据区域

![jvm](../../img/jvm.png)

# 线程隔离的数据区

## 程序计数器(Program Counter Register)

程序计数器是一块较小的内存空间，可以看作是**当前线程所执行的字节码的行号指示器。**字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

每条线程都需要一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，这类内存区域为“线程私有”的内存。

如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；  
如果正在执行的是Native方法，这个计数器值则为空。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

## Java虚拟机栈(Java Virtual Machine Stacks)

Java虚拟机栈是**线程私有的**，它的生命周期与线程相同。

每个方法执行时都会创建一个栈针用于**存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈针在虚拟机栈中入栈和出栈的过程。**

局部变量表**存放了编译期可知的各种基本类型(boolean byte char short int float long double)、对象引用(reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置)和return Address类型(指向了一条字节码指令的地址)。**

其中64位长度的long和double类型的数据会占用2个局部变量空间，其余的数据类型只占1个。局部变量表所需的内存空间在编译期间完成分配，在方法运行期间不会改变局部变量表的大小。

如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。
如果虚拟机栈可以自动扩展，扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。

## 本地方法栈(Native Method Stack)

**本地方法栈为虚拟机使用到的Native方法服务。**

# 线程共享的数据区

## Java堆(Java Heap)

Java堆是Java虚拟机所管理的内存中最大的一块。Java堆是**被所有线程共享的一块内存区域**，在虚拟机启动时创建。**此区域的唯一的目的就是存放对象实例。**几乎所有的对象实例都在这里分配内存。

Java堆中还可以细分为：新生代和老年代。

### **对象的创建**：
对象的创建分为以下几步：

- 第一步：当虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过，如果没有，那么必须执行相应的类加载过程。

- 第二步：接下来虚拟机将为新生对象分配内存，对象所需内存的大小在类加载完成后便可确定，分配的方式有两种：
    - 指针碰撞：用过和空闲的内存以指针作为分界点的指示器，分配内存就是把指针向空闲空间那边挪动一个与对象大小相等距离，这种方式要求内存是规整的。
    - 空闲列表：维护一个列表，记录哪些内存是可用的，在分配和回收时更新列表。
    - 对分配内存空间的动作进行同步，虚拟机上采用CAS配上失败重试的方式保证更新操作的原子性。
    - 每个线程在Java堆中预先分配一小块内存，成为本地线程分配缓冲TLAB，哪个线程需要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完需要分配新的TLAB才需要同步。

- 第三步：在内存分配完成，把除了对象头之外的分配到的内存空间都初始化为零值，接下来就是对对象进行必要的设置，这些信息存放在对象头中。

- 第四步：当对象头设置完毕之后，从虚拟机的视角来看，新的对象就产生了，接着就执行< init>方法，把对象按照程序员的意愿进行初始化。

### **对象的内存布局：**
对象在内存中存储的布局可以分为三个区域：对象头、实例数据、对其填充。

- 对象头
    - 存储对象自身的运行时数据：HashCode、Gc分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，所占位数和虚拟机位数相同。
    - 类型指针：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例
    - 如果对象是一个Java数组，那么在对象头中还必须有一块记录数组长度的数据。

- 实例数据
包括在父类和子类中所定义的各种类型的字段内容，存储顺序收到虚拟机分配策略参数的影响，相同宽度的字段总是被分配到一起，在满足这个前提条件下，父类中定义的变量会出现在子类之前。

- 对齐填充
HotSpot要求对象的大小必须是8字节的整数倍，而对象头部分正好是8字节的整数倍，当对象实例数据部分没有对齐时，就需要通过对齐填充来不全。

### ** 对象的访问：**
对象的访问有两种方式：

- 使用句柄，Java堆中划分出一块内存作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的地址信息。

    优点：reference中存储的是稳定的句柄地址，在对象被移动时，只会改变句柄中的实例数据指针，而reference本身不需要修改。

- 直接指针：在Java堆对象的布局中放置访问类型数据的相关信息，reference中存储的直接就是对象地址。

    优点：速度快，HotSpot采用的就是这种方式。


## 方法区(Method Area)

各个线程共享的内存区域，它用于**存储已被虚拟机加载的类信息、常量、静态常量、即时编译器编译后的代码等数据**。

## 运行时常量池(Runtime Constant Pool)

运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息时常量池，**用于存放编译期生成的各种字面量和符号引用**，这部分内容将在类加载后进入方法区的运行时常量池中。

## 直接内存(Direct Memory)

不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中的内存区域。

