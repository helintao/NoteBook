# 标记-清除算法

首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对。

不足：

- 效率问题，标记和清除这两个过程的效率都不高

- 空间问题，标记清楚之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后再程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

# 复制算法

将可用内存容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另一块上面。然后再把已使用过的内存空间一次清理掉。

不足：内存缩小为原来的一半，代价高。

现在的商业虚拟机都采用这种收集算法来回收新生代。将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。  
HotSpot虚拟机默认Eden和Survivor的大小比例是8：1。也就是每次新生代中可用内存空间为整个新生代容量的(80%+10%)，只用10%的内存会被“浪费”。

# 标记-整理算法

标记过程和“标记-清除”算法一样。整理过程让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

# 分代收集算法

当前商业虚拟机的垃圾收集都采用“分代收集(Generational Collection)”算法。

根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中采用复制算法，而老年代采用“标记-整理”算法。
 
