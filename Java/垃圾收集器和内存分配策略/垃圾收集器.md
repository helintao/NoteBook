# 垃圾收集器 

程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。

Java堆和方法区不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序运行期间才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存。

## 引用计数法

给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。

Java虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象间相互循环引用的问题。

## 可达性分析算法

这个算法的基本思路就是通过一系列的称为"GC Roots"的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连(用图论的话来说，就是从GC Roots到这个对象不可达)时，则证明此对象是不可用的。

Java是通过可达性分析算法来判断对象是否存活的。

在Java语言中，可作为GC Roots的对象包括下面几种：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象

- 方法区中类静态属性引用的对象

- 方法区中常量引用的对象

- 本地方法占中JNI（即一般说的Native方法）引用的对象

# 对象的死亡

一个对象的死亡，至少经历两次标记过程：如果对象在进行可达性分析后发现没有与GCRoots相连的引用链，那么它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法或者finalize()方法已被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。

# 回收方法区

回收常量池中的常量：当没有其他地方引用常量的字面量时发生内存回收，并且有必要的话，常量会被系统清理出常量池。

回收一个类，需同时满足下面3个条件：

- 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。

- 加载该类的ClassLoader已经被回收。

- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

虚拟机**可以**对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”,而并不是和对象一样，不使用了就必然会回收。